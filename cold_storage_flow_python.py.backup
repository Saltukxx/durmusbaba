"""
Cold Storage Flow Handler for Python
Manages the step-by-step questionnaire for cold storage calculations
"""

import json
import re
from cold_room_calculator import calculate_capacity

# Question templates
QUESTIONS = {
    'en': {
        'temperature': "What is the required cold room temperature? (¬∞C)\n\nSupported temperatures: 12, 5, 0, -5, -15, -18, -20, -25¬∞C",
        'products': "What product(s) will be stored inside the room?\n\nExample: Fruits, vegetables, meat, dairy, etc.",
        'length': "What is the inner length of the room? (in meters)\n\nExample: 5.5",
        'width': "What is the inner width of the room? (in meters)\n\nExample: 3.2",
        'height': "What is the inner height of the room? (in meters)\n\nExample: 2.8",
        'insulation': "What is the thickness of insulation panels?\n\nExample: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Is there floor insulation?\n\nReply: Yes or No",
        'door_frequency': "How often will the door be opened daily?\n\nExample: 10 times, rarely, frequently",
        'loading_amount': "What is the daily loading/unloading amount? (in kg)\n\nExample: 500 kg",
        'entry_temperature': "What is the temperature of products when they enter the room? (¬∞C)\n\nExample: 20¬∞C",
        'cooling_duration': "What is the required cooling duration? (in hours)\n\nExample: 24 hours, 48 hours",
        'cooling_type': "What type of cooling system do you prefer?\n\nOptions: Air cooling, Direct expansion, Evaporative",
        'unit_preference': "What type of unit do you prefer?\n\nOptions: Monoblock, Split system, Modular system",
        'electricity_type': "What type of electricity supply?\n\nOptions: Single phase (220V), Three phase (380V/400V)",
        'installation_city': "In which city will the installation be?\n\nExample: Istanbul, Berlin, London",
        'ambient_heat_source': "Are there any ambient heat sources nearby?\n\nExample: Ovens, boilers, direct sunlight",
        'usage_area': "What is the usable area or number of pallets?\n\nExample: 50 m¬≤ or 20 pallets",
        'drawing_photo': "Do you have technical drawings or photos of the space?\n\nReply: Yes or No (you can send them later)"
    },
    'tr': {
        'temperature': "Gerekli soƒüuk oda sƒ±caklƒ±ƒüƒ± nedir? (¬∞C)\n\nDesteklenen sƒ±caklƒ±klar: 12, 5, 0, -5, -15, -18, -20, -25¬∞C",
        'products': "Oda i√ßerisinde hangi √ºr√ºn(ler) saklanacak?\n\n√ñrnek: Meyve, sebze, et, s√ºt √ºr√ºnleri, vb.",
        'length': "Odanƒ±n i√ß uzunluƒüu nedir? (metre cinsinden)\n\n√ñrnek: 5.5",
        'width': "Odanƒ±n i√ß geni≈üliƒüi nedir? (metre cinsinden)\n\n√ñrnek: 3.2",
        'height': "Odanƒ±n i√ß y√ºksekliƒüi nedir? (metre cinsinden)\n\n√ñrnek: 2.8",
        'insulation': "Yalƒ±tƒ±m panellerinin kalƒ±nlƒ±ƒüƒ± nedir?\n\n√ñrnek: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Zemin yalƒ±tƒ±mƒ± var mƒ±?\n\nCevap: Evet veya Hayƒ±r",
        'door_frequency': "Kapƒ± g√ºnde ka√ß kez a√ßƒ±lacak?\n\n√ñrnek: 10 kez, nadir, sƒ±k sƒ±k",
        'loading_amount': "G√ºnl√ºk y√ºkleme/bo≈üaltma miktarƒ± nedir? (kg cinsinden)\n\n√ñrnek: 500 kg",
        'entry_temperature': "√úr√ºnler odaya girdiƒüinde sƒ±caklƒ±ƒüƒ± nedir? (¬∞C)\n\n√ñrnek: 20¬∞C",
        'cooling_duration': "Gerekli soƒüuma s√ºresi nedir? (saat cinsinden)\n\n√ñrnek: 24 saat, 48 saat",
        'cooling_type': "Hangi tip soƒüutma sistemi tercih ediyorsunuz?\n\nSe√ßenekler: Hava soƒüutmalƒ±, Direkt ekspansiyonlu, Evaporatif",
        'unit_preference': "Hangi tip √ºnite tercih ediyorsunuz?\n\nSe√ßenekler: Monoblock, Split sistem, Mod√ºler sistem",
        'electricity_type': "Elektrik tipi nedir?\n\nSe√ßenekler: Tek faz (220V), √ú√ß faz (380V/400V)",
        'installation_city': "Kurulum hangi ≈üehirde yapƒ±lacak?\n\n√ñrnek: ƒ∞stanbul, Ankara, ƒ∞zmir",
        'ambient_heat_source': "√áevrede ƒ±sƒ± kaynaƒüƒ± var mƒ±?\n\n√ñrnek: Fƒ±rƒ±nlar, kazanlar, doƒürudan g√ºne≈ü ƒ±≈üƒ±ƒüƒ±",
        'usage_area': "Kullanƒ±m alanƒ± veya palet sayƒ±sƒ± nedir?\n\n√ñrnek: 50 m¬≤ veya 20 palet",
        'drawing_photo': "Mekanƒ±n teknik √ßizimi veya fotoƒürafƒ± var mƒ±?\n\nCevap: Evet veya Hayƒ±r (daha sonra g√∂nderebilirsiniz)"
    },
    'de': {
        'temperature': "Welche K√ºhlraumtemperatur ist erforderlich? (¬∞C)\n\nUnterst√ºtzte Temperaturen: 12, 5, 0, -5, -15, -18, -20, -25¬∞C",
        'products': "Welche Produkte werden im Raum gelagert?\n\nBeispiel: Obst, Gem√ºse, Fleisch, Milchprodukte, usw.",
        'length': "Wie lang ist der Raum innen? (in Metern)\n\nBeispiel: 5.5",
        'width': "Wie breit ist der Raum innen? (in Metern)\n\nBeispiel: 3.2",
        'height': "Wie hoch ist der Raum innen? (in Metern)\n\nBeispiel: 2.8",
        'insulation': "Wie dick sind die Isolierpaneele?\n\nBeispiel: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Gibt es eine Bodenisolierung?\n\nAntwort: Ja oder Nein",
        'door_frequency': "Wie oft wird die T√ºr t√§glich ge√∂ffnet?\n\nBeispiel: 10 mal, selten, h√§ufig",
        'loading_amount': "Wie viel wird t√§glich be-/entladen? (in kg)\n\nBeispiel: 500 kg",
        'entry_temperature': "Welche Temperatur haben die Produkte beim Einlagern? (¬∞C)\n\nBeispiel: 20¬∞C",
        'cooling_duration': "Wie lange soll die K√ºhlung dauern? (in Stunden)\n\nBeispiel: 24 Stunden, 48 Stunden",
        'cooling_type': "Welchen K√ºhlungstyp bevorzugen Sie?\n\nOptionen: Luftk√ºhlung, Direktexpansion, Verdunstungsk√ºhlung",
        'unit_preference': "Welchen Ger√§tetyp bevorzugen Sie?\n\nOptionen: Monoblock, Split-System, Modulares System",
        'electricity_type': "Welcher Stromtyp?\n\nOptionen: Einphasig (220V), Dreiphasig (380V/400V)",
        'installation_city': "In welcher Stadt erfolgt die Installation?\n\nBeispiel: Berlin, M√ºnchen, Hamburg",
        'ambient_heat_source': "Gibt es W√§rmequellen in der Umgebung?\n\nBeispiel: √ñfen, Kessel, direktes Sonnenlicht",
        'usage_area': "Wie gro√ü ist die Nutzfl√§che oder wie viele Paletten?\n\nBeispiel: 50 m¬≤ oder 20 Paletten",
        'drawing_photo': "Haben Sie technische Zeichnungen oder Fotos des Raums?\n\nAntwort: Ja oder Nein (k√∂nnen sp√§ter gesendet werden)"
    }
}

# Progress messages
PROGRESS_MESSAGES = {
    'en': {
        'progress': "Progress: {current}/{total} questions completed",
        'calculation': "üîÑ Calculating your cold storage requirements...",
        'complete': "‚úÖ Calculation complete! Here are your results:",
        'restart': "To start a new calculation, send 'cold room' or 'soƒüuk oda'."
    },
    'tr': {
        'progress': "ƒ∞lerleme: {current}/{total} soru tamamlandƒ±",
        'calculation': "üîÑ Soƒüuk hava deposu gereksinimleriniz hesaplanƒ±yor...",
        'complete': "‚úÖ Hesaplama tamamlandƒ±! ƒ∞≈üte sonu√ßlarƒ±nƒ±z:",
        'restart': "Yeni bir hesaplama ba≈ülatmak i√ßin 'cold room' veya 'soƒüuk oda' g√∂nderin."
    },
    'de': {
        'progress': "Fortschritt: {current}/{total} Fragen beantwortet",
        'calculation': "üîÑ Ihre K√ºhlraum-Anforderungen werden berechnet...",
        'complete': "‚úÖ Berechnung abgeschlossen! Hier sind Ihre Ergebnisse:",
        'restart': "F√ºr eine neue Berechnung senden Sie 'cold room' oder 'k√ºhlraum'."
    }
}

# Question flow order - Updated to match JavaScript version with 18 questions
QUESTION_ORDER = [
    'temperature',
    'products',
    'length',
    'width',
    'height',
    'insulation',
    'floor_insulation',
    'door_frequency',
    'loading_amount',
    'entry_temperature',
    'cooling_duration',
    'cooling_type',
    'unit_preference',
    'electricity_type',
    'installation_city',
    'ambient_heat_source',
    'usage_area',
    'drawing_photo'
]

# In-memory storage for user sessions (in production, use a database)
USER_SESSIONS = {}

def initialize_cold_storage_flow(user_id, language='en'):
    """
    Initialize cold storage flow for a user
    Args:
        user_id (str): User ID
        language (str): Language code (en/tr/de)
    Returns:
        str: Welcome message and first question
    """
    USER_SESSIONS[user_id] = {
        'active': True,
        'language': language,
        'current_step': 0,
        'answers': {},
        'start_time': None
    }
    
    # Welcome messages with commands
    welcome_messages = {
        'en': "‚ùÑÔ∏è Welcome to the Cold Room Calculator! üßä\n\nI'll help you calculate the exact cooling capacity needed for your cold storage room. We'll go through 18 comprehensive questions to get accurate results.\n\nüìã **HELPFUL COMMANDS YOU CAN USE:**\n‚úÖ Type **'wrong'** if you made a mistake\n‚úÖ Type **'show'** to see all your answers\n‚úÖ Type **'restart'** to start over completely\n‚úÖ Type **'stop'** to exit\n\nüí° You can use these commands at any time during the questions!\n\nüéØ Let's get started!",
        'tr': "‚ùÑÔ∏è Soƒüuk Oda Hesaplayƒ±cƒ±sƒ±na Ho≈ü Geldiniz! üßä\n\nSoƒüuk hava deponuz i√ßin gereken tam soƒüutma kapasitesini hesaplamanƒ±za yardƒ±mcƒ± olacaƒüƒ±m. Doƒüru sonu√ßlar i√ßin 18 kapsamlƒ± soru soracaƒüƒ±m.\n\nüìã **KULLANABƒ∞LECEƒûƒ∞Nƒ∞Z YARDIMCI KOMUTLAR:**\n‚úÖ Hata yaptƒ±ysanƒ±z **'yanlƒ±≈ü'** yazƒ±n\n‚úÖ T√ºm cevaplarƒ±nƒ±zƒ± g√∂rmek i√ßin **'g√∂ster'** yazƒ±n\n‚úÖ Tamamen yeniden ba≈ülamak i√ßin **'restart'** yazƒ±n\n‚úÖ √áƒ±kmak i√ßin **'dur'** yazƒ±n\n\nüí° Bu komutlarƒ± sorular sƒ±rasƒ±nda istediƒüiniz zaman kullanabilirsiniz!\n\nüéØ Hadi ba≈ülayalƒ±m!",
        'de': "‚ùÑÔ∏è Willkommen beim K√ºhlraum-Rechner! üßä\n\nIch helfe Ihnen bei der Berechnung der exakten K√ºhlkapazit√§t f√ºr Ihren K√ºhlraum. Wir gehen 18 umfassende Fragen durch, um genaue Ergebnisse zu erhalten.\n\nüìã **HILFREICHE BEFEHLE DIE SIE VERWENDEN K√ñNNEN:**\n‚úÖ Geben Sie **'falsch'** ein, wenn Sie einen Fehler gemacht haben\n‚úÖ Geben Sie **'zeigen'** ein, um alle Ihre Antworten zu sehen\n‚úÖ Geben Sie **'restart'** ein, um komplett neu zu beginnen\n‚úÖ Geben Sie **'stopp'** ein, um zu beenden\n\nüí° Sie k√∂nnen diese Befehle jederzeit w√§hrend der Fragen verwenden!\n\nüéØ Los geht's!"
    }
    
    welcome_message = welcome_messages.get(language, welcome_messages['en'])
    first_question = ask_current_question(user_id)
    
    return f"{welcome_message}\n\n{first_question}"

def process_answer(user_id, answer):
    """
    Process user answer and move to next question
    Args:
        user_id (str): User ID
        answer (str): User's answer
    Returns:
        str: Next question or calculation result
    """
    if user_id not in USER_SESSIONS:
        return "No active session found. Please start a new calculation."
    
    session = USER_SESSIONS[user_id]
    
    # Check for special commands first
    if is_cancel_request(answer):
        return cancel_cold_storage_flow(user_id)
    
    if is_back_request(answer):
        return go_back_to_previous_question(user_id)
    
    if is_restart_request(answer):
        # Reset the flow
        session['current_step'] = 0
        session['answers'] = {}
        restart_messages = {
            'en': f"üîÑ Restarting cold storage calculation...\n\n{ask_current_question(user_id)}",
            'tr': f"üîÑ Soƒüuk depo hesaplamasƒ± yeniden ba≈ülatƒ±lƒ±yor...\n\n{ask_current_question(user_id)}",
            'de': f"üîÑ K√§ltelagerberechnung wird neu gestartet...\n\n{ask_current_question(user_id)}"
        }
        return restart_messages.get(session['language'], restart_messages['en'])
    
    if is_show_request(answer):
        return show_current_answers(user_id)
    
    current_question_key = QUESTION_ORDER[session['current_step']]
    
    # Validate and store answer
    validation_result = validate_answer(current_question_key, answer)
    if validation_result['error']:
        # Add helpful commands reminder when there's an error
        help_texts = {
            'en': "\n\nüí° Need help? Type 'wrong' to go back, 'show' to see answers, or 'restart' to start over.",
            'tr': "\n\nüí° Yardƒ±m mƒ± lazƒ±m? 'yanlƒ±≈ü' yazarak geri gidin, 'g√∂ster' ile cevaplarƒ± g√∂r√ºn, ya da 'restart' ile yeniden ba≈ülayƒ±n.",
            'de': "\n\nüí° Hilfe ben√∂tigt? Geben Sie 'falsch' ein um zur√ºckzugehen, 'zeigen' f√ºr Antworten, oder 'restart' f√ºr Neustart."
        }
        help_text = help_texts.get(session['language'], help_texts['en'])
        return validation_result['error'] + "\n\n" + QUESTIONS[session['language']][current_question_key] + help_text
    
    session['answers'][current_question_key] = validation_result['value']
    session['current_step'] += 1
    
    # Check if all questions are answered
    if session['current_step'] >= len(QUESTION_ORDER):
        return calculate_and_finish(user_id)
    
    return ask_current_question(user_id)

def ask_current_question(user_id):
    """
    Ask the current question
    Args:
        user_id (str): User ID
    Returns:
        str: Current question with commands
    """
    session = USER_SESSIONS[user_id]
    current_question_key = QUESTION_ORDER[session['current_step']]
    question = QUESTIONS[session['language']][current_question_key]
    
    progress = PROGRESS_MESSAGES[session['language']]['progress'].format(
        current=session['current_step'] + 1,
        total=len(QUESTION_ORDER)
    )
    
    # Add helpful commands
    command_texts = {
        'en': "\n\nüí¨ Commands: 'wrong' | 'show' | 'restart' | 'stop'",
        'tr': "\n\nüí¨ Komutlar: 'yanlƒ±≈ü' | 'g√∂ster' | 'restart' | 'dur'",
        'de': "\n\nüí¨ Befehle: 'falsch' | 'zeigen' | 'restart' | 'stopp'"
    }
    
    command_text = command_texts.get(session['language'], command_texts['en'])
    
    return f"{progress}\n\n{question}{command_text}"

def validate_answer(question_key, answer):
    """
    Validate user answer based on question type
    Args:
        question_key (str): Question identifier
        answer (str): User's answer
    Returns:
        dict: Validation result with 'error' and 'value' keys
    """
    clean_answer = answer.strip()
    
    if question_key == 'temperature':
        try:
            temp = float(re.sub(r'[¬∞C]', '', clean_answer))
            supported_temps = [12, 5, 0, -5, -15, -18, -20, -25]
            if temp not in supported_temps:
                return {'error': "‚ùå Please enter a valid temperature from the supported list.", 'value': None}
            return {'error': None, 'value': temp}
        except ValueError:
            return {'error': "‚ùå Please enter a valid temperature from the supported list.", 'value': None}
    
    elif question_key == 'products':
        if len(clean_answer) < 2:
            return {'error': "‚ùå Please describe the products to be stored.", 'value': None}
        return {'error': None, 'value': clean_answer}
    
    elif question_key in ['length', 'width', 'height']:
        try:
            dimension = float(re.sub(r'[m]', '', clean_answer))
            if dimension <= 0 or dimension > 50:
                return {'error': "‚ùå Please enter a valid dimension in meters (0.1 - 50).", 'value': None}
            return {'error': None, 'value': dimension}
        except ValueError:
            return {'error': "‚ùå Please enter a valid dimension in meters (0.1 - 50).", 'value': None}
    
    elif question_key == 'insulation':
        try:
            thickness = float(re.sub(r'[cm]', '', clean_answer))
            if thickness < 5 or thickness > 30:
                return {'error': "‚ùå Please enter insulation thickness in cm (5-30 cm).", 'value': None}
            return {'error': None, 'value': thickness}
        except ValueError:
            return {'error': "‚ùå Please enter insulation thickness in cm (5-30 cm).", 'value': None}
    
    elif question_key == 'floor_insulation':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['yes', 'evet', 'ja']):
            return {'error': None, 'value': True}
        elif any(word in lower_answer for word in ['no', 'hayƒ±r', 'nein']):
            return {'error': None, 'value': False}
        else:
            return {'error': "‚ùå Please answer 'Yes'/'Evet'/'Ja' or 'No'/'Hayƒ±r'/'Nein' for floor insulation.", 'value': None}
    
    elif question_key == 'door_frequency':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['rare', 'nadir', 'selten']):
            return {'error': None, 'value': 2}
        elif any(word in lower_answer for word in ['frequent', 'sƒ±k', 'h√§ufig']):
            return {'error': None, 'value': 20}
        else:
            try:
                number = int(re.sub(r'[^0-9]', '', clean_answer))
                if 0 <= number <= 100:
                    return {'error': None, 'value': number}
                else:
                    return {'error': "‚ùå Please enter door opening frequency (number of times per day or 'rarely'/'frequently').", 'value': None}
            except ValueError:
                return {'error': "‚ùå Please enter door opening frequency (number of times per day or 'rarely'/'frequently').", 'value': None}
    
    elif question_key == 'loading_amount':
        try:
            amount = float(re.sub(r'[kg]', '', clean_answer))
            if amount < 0 or amount > 50000:
                return {'error': "‚ùå Please enter daily loading amount in kg (0-50000).", 'value': None}
            return {'error': None, 'value': amount}
        except ValueError:
            return {'error': "‚ùå Please enter daily loading amount in kg (0-50000).", 'value': None}
    
    elif question_key == 'entry_temperature':
        try:
            temp = float(re.sub(r'[¬∞C]', '', clean_answer))
            if temp < -30 or temp > 60:
                return {'error': "‚ùå Please enter product entry temperature in ¬∞C (-30 to 60).", 'value': None}
            return {'error': None, 'value': temp}
        except ValueError:
            return {'error': "‚ùå Please enter product entry temperature in ¬∞C (-30 to 60).", 'value': None}
    
    elif question_key == 'cooling_duration':
        try:
            duration = float(re.sub(r'(hours|hour|saat|stunden)', '', clean_answer, flags=re.IGNORECASE))
            if duration < 1 or duration > 168:
                return {'error': "‚ùå Please enter cooling duration in hours (1-168 hours).", 'value': None}
            return {'error': None, 'value': duration}
        except ValueError:
            return {'error': "‚ùå Please enter cooling duration in hours (1-168 hours).", 'value': None}
    
    elif question_key == 'cooling_type':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['air', 'hava', 'luft']):
            return {'error': None, 'value': 'air'}
        elif any(word in lower_answer for word in ['direct', 'direkt']):
            return {'error': None, 'value': 'direct'}
        elif any(word in lower_answer for word in ['evap', 'verdun']):
            return {'error': None, 'value': 'evaporative'}
        else:
            return {'error': "‚ùå Please select: Air cooling, Direct expansion, or Evaporative.", 'value': None}
    
    elif question_key == 'unit_preference':
        lower_answer = clean_answer.lower()
        if 'mono' in lower_answer:
            return {'error': None, 'value': 'monoblock'}
        elif 'split' in lower_answer:
            return {'error': None, 'value': 'split'}
        elif 'modul' in lower_answer:
            return {'error': None, 'value': 'modular'}
        else:
            return {'error': "‚ùå Please select: Monoblock, Split system, or Modular system.", 'value': None}
    
    elif question_key == 'electricity_type':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['single', 'tek', '220']):
            return {'error': None, 'value': 'single'}
        elif any(word in lower_answer for word in ['three', '√º√ß', 'drei', '380', '400']):
            return {'error': None, 'value': 'three'}
        else:
            return {'error': "‚ùå Please select: Single phase (220V) or Three phase (380V/400V).", 'value': None}
    
    elif question_key == 'installation_city':
        if len(clean_answer) < 2:
            return {'error': "‚ùå Please enter the installation city name.", 'value': None}
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'ambient_heat_source':
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'usage_area':
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'drawing_photo':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['yes', 'evet', 'ja']):
            return {'error': None, 'value': True}
        elif any(word in lower_answer for word in ['no', 'hayƒ±r', 'nein']):
            return {'error': None, 'value': False}
        else:
            return {'error': "‚ùå Please answer 'Yes'/'Evet'/'Ja' or 'No'/'Hayƒ±r'/'Nein'.", 'value': None}
    
    return {'error': "‚ùå Invalid question type.", 'value': None}

def is_cancel_request(message):
    """Check if user wants to cancel current session"""
    cancel_keywords = ['cancel', 'stop', 'quit', 'exit', 'iptal', 'dur', '√ßƒ±k', 'abbrechen', 'stopp', 'beenden']
    return message.lower().strip() in cancel_keywords

def is_back_request(message):
    """Check if user wants to go back to previous question"""
    back_keywords = ['back', 'previous', 'go back', 'geri', '√∂nceki', 'zur√ºck', 'vorherige', 'wrong', 'mistake', 'error', 'yanlƒ±≈ü', 'hata', 'falsch', 'fehler']
    return any(keyword in message.lower() for keyword in back_keywords)

def is_restart_request(message):
    """Check if user wants to restart calculation"""
    restart_keywords = ['restart', 'start over', 'begin again', 'yeniden ba≈üla', 'tekrar ba≈üla', 'neu starten', 'von vorne']
    return any(keyword in message.lower() for keyword in restart_keywords)

def is_show_request(message):
    """Check if user wants to show current answers"""
    show_keywords = ['show', 'display', 'review', 'answers', 'g√∂ster', 'cevaplar', 'zeigen', 'antworten']
    return any(keyword in message.lower() for keyword in show_keywords)

def cancel_cold_storage_flow(user_id):
    """Cancel active cold storage session"""
    if user_id in USER_SESSIONS:
        language = USER_SESSIONS[user_id].get('language', 'en')
        del USER_SESSIONS[user_id]
        
        messages = {
            'en': "‚ùå Cold storage calculation cancelled. Type 'cold storage' to start again.",
            'tr': "‚ùå Soƒüuk depo hesaplamasƒ± iptal edildi. Tekrar ba≈ülamak i√ßin 'soƒüuk depo' yazƒ±n.",
            'de': "‚ùå K√§ltelagerberechnung abgebrochen. Geben Sie 'K√ºhlraum' ein, um erneut zu beginnen."
        }
        
        return messages.get(language, messages['en'])
    
    return None

def go_back_to_previous_question(user_id):
    """Go back to previous question"""
    if user_id not in USER_SESSIONS:
        return "No active session found."
    
    session = USER_SESSIONS[user_id]
    language = session['language']
    
    if session['current_step'] <= 0:
        messages = {
            'en': "‚ùå You're already at the first question. Type 'restart' to start over.",
            'tr': "‚ùå Zaten ilk sorudasƒ±nƒ±z. Yeniden ba≈ülamak i√ßin 'restart' yazƒ±n.",
            'de': "‚ùå Sie sind bereits bei der ersten Frage. Geben Sie 'restart' ein, um von vorne zu beginnen."
        }
        return messages.get(language, messages['en'])
    
    # Go back one step and remove the previous answer
    session['current_step'] -= 1
    previous_question_key = QUESTION_ORDER[session['current_step']]
    if previous_question_key in session['answers']:
        del session['answers'][previous_question_key]
    
    back_messages = {
        'en': "‚¨ÖÔ∏è Going back to previous question:",
        'tr': "‚¨ÖÔ∏è √ñnceki soruya d√∂n√ºl√ºyor:",
        'de': "‚¨ÖÔ∏è Zur√ºck zur vorherigen Frage:"
    }
    
    back_message = back_messages.get(language, back_messages['en'])
    question = ask_current_question(user_id)
    
    return f"{back_message}\n\n{question}"

def show_current_answers(user_id):
    """Show current answers for review"""
    if user_id not in USER_SESSIONS:
        return "No active session found."
    
    session = USER_SESSIONS[user_id]
    language = session['language']
    answers = session['answers']
    
    headers = {
        'en': {
            'title': "üìã Your Current Answers:",
            'noAnswers': "‚ùå No answers recorded yet.",
            'commands': "\nüí° Commands:\n‚Ä¢ Type 'back' to go to previous question\n‚Ä¢ Type 'restart' to start over\n‚Ä¢ Continue answering to proceed"
        },
        'tr': {
            'title': "üìã Mevcut Cevaplarƒ±nƒ±z:",
            'noAnswers': "‚ùå Hen√ºz hi√ß cevap kaydedilmedi.",
            'commands': "\nüí° Komutlar:\n‚Ä¢ √ñnceki soruya d√∂nmek i√ßin 'back' yazƒ±n\n‚Ä¢ Yeniden ba≈ülamak i√ßin 'restart' yazƒ±n\n‚Ä¢ Devam etmek i√ßin cevaplamaya devam edin"
        },
        'de': {
            'title': "üìã Ihre aktuellen Antworten:",
            'noAnswers': "‚ùå Noch keine Antworten aufgezeichnet.",
            'commands': "\nüí° Befehle:\n‚Ä¢ Geben Sie 'back' ein, um zur vorherigen Frage zu gehen\n‚Ä¢ Geben Sie 'restart' ein, um von vorne zu beginnen\n‚Ä¢ Setzen Sie das Beantworten fort, um fortzufahren"
        }
    }
    
    h = headers.get(language, headers['en'])
    
    if len(answers) == 0:
        return h['noAnswers'] + h['commands']
    
    response = h['title'] + "\n\n"
    
    for i in range(session['current_step']):
        question_key = QUESTION_ORDER[i]
        answer = answers.get(question_key)
        if answer is not None:
            response += f"{i + 1}. {question_key}: {answer}\n"
    
    response += h['commands']
    return response

def calculate_and_finish(user_id):
    """
    Calculate results and finish the flow
    Args:
        user_id (str): User ID
    Returns:
        str: Final calculation result
    """
    session = USER_SESSIONS[user_id]
    answers = session['answers']
    
    try:
        # Calculate room volume
        volume = answers['length'] * answers['width'] * answers['height']
        
        # Estimate ambient temperature based on geographical assumptions
        ambient_temp = 35  # Default assumption for calculations
        
        # Calculate additional loads
        additional_loads = calculate_additional_loads(answers)
        
        # Base calculation parameters
        calc_params = {
            'volume': volume,
            'temperature': answers['temperature'],
            'ambient_temp': ambient_temp,
            'climate_zone': 'cool',  # Default
            'safety_factor': 1.2  # Default safety factor
        }
        
        # Get base calculation
        base_result = calculate_capacity(**calc_params)
        
        # Add additional loads
        final_capacity = base_result['final_capacity'] + additional_loads['total']
        
        # Format comprehensive result
        result = format_cold_storage_result(answers, volume, final_capacity, additional_loads, session['language'])
        
        # Clean up session
        del USER_SESSIONS[user_id]
        
        return PROGRESS_MESSAGES[session['language']]['complete'] + "\n\n" + result + "\n\n" + PROGRESS_MESSAGES[session['language']]['restart']
        
    except Exception as error:
        del USER_SESSIONS[user_id]
        return "‚ùå Sorry, there was an error calculating your requirements. Please try again."

def calculate_additional_loads(answers):
    """
    Calculate additional loads based on specific parameters
    Args:
        answers (dict): User answers
    Returns:
        dict: Additional loads breakdown
    """
    loads = {
        'infiltration': 0,
        'product': 0,
        'floor': 0,
        'total': 0
    }
    
    volume = answers['length'] * answers['width'] * answers['height']
    
    # Infiltration load (door openings)
    infiltration_factor = min(answers['door_frequency'] * 0.1, 2.0)  # Max 200% increase
    loads['infiltration'] = volume * infiltration_factor * 15  # 15W per m¬≥ per door opening factor
    
    # Product load (cooling from entry temperature to storage temperature)
    temp_diff = answers['entry_temperature'] - answers['temperature']
    product_load = answers['loading_amount'] * temp_diff * 0.5  # Simplified: 0.5W per kg per ¬∞C difference
    loads['product'] = max(product_load, 0)
    
    # Floor load (if no insulation)
    if not answers['floor_insulation']:
        loads['floor'] = answers['length'] * answers['width'] * 20  # 20W per m¬≤ for uninsulated floor
    
    loads['total'] = loads['infiltration'] + loads['product'] + loads['floor']
    
    return loads

def format_cold_storage_result(answers, volume, final_capacity, additional_loads, language):
    """
    Format the final calculation result
    Args:
        answers (dict): User answers
        volume (float): Room volume
        final_capacity (float): Final cooling capacity
        additional_loads (dict): Additional loads breakdown
        language (str): Language code
    Returns:
        str: Formatted result
    """
    # Language-specific text mappings
    texts = {
        'en': {
            'title': 'Cold Storage Calculation Results',
            'room_specs': 'Room Specifications',
            'dimensions': 'Dimensions',
            'volume': 'Volume',
            'temperature': 'Temperature',
            'products': 'Products',
            'insulation': 'Insulation',
            'floor_insulation': 'Floor Insulation',
            'yes': 'Yes',
            'no': 'No',
            'operational_params': 'Operational Parameters',
            'door_frequency': 'Door Opening Frequency',
            'times_per_day': 'times/day',
            'daily_loading': 'Daily Loading',
            'entry_temp': 'Product Entry Temperature',
            'cooling_capacity': 'Cooling Capacity',
            'base_capacity': 'Base Capacity',
            'infiltration_load': 'Infiltration Load',
            'product_load': 'Product Cooling Load',
            'floor_load': 'Floor Load',
            'total_capacity': 'TOTAL CAPACITY',
            'in_kw': 'In kW'
        },
        'tr': {
            'title': 'Soƒüuk Hava Deposu Hesaplama Sonu√ßlarƒ±',
            'room_specs': 'Oda √ñzellikleri',
            'dimensions': 'Boyutlar',
            'volume': 'Hacim',
            'temperature': 'Sƒ±caklƒ±k',
            'products': '√úr√ºn',
            'insulation': 'Yalƒ±tƒ±m',
            'floor_insulation': 'Zemin Yalƒ±tƒ±mƒ±',
            'yes': 'Var',
            'no': 'Yok',
            'operational_params': '√áalƒ±≈üma Parametreleri',
            'door_frequency': 'Kapƒ± A√ßma Sƒ±klƒ±ƒüƒ±',
            'times_per_day': 'kez/g√ºn',
            'daily_loading': 'G√ºnl√ºk Y√ºkleme',
            'entry_temp': '√úr√ºn Giri≈ü Sƒ±caklƒ±ƒüƒ±',
            'cooling_capacity': 'Soƒüutma Kapasitesi',
            'base_capacity': 'Temel Kapasite',
            'infiltration_load': 'Infiltrasyon Y√ºk√º',
            'product_load': '√úr√ºn Soƒüutma Y√ºk√º',
            'floor_load': 'Zemin Y√ºk√º',
            'total_capacity': 'TOPLAM KAPASƒ∞TE',
            'in_kw': 'kW Cinsinden'
        },
        'de': {
            'title': 'K√ºhlraum-Berechnungsergebnisse',
            'room_specs': 'Raum-Spezifikationen',
            'dimensions': 'Abmessungen',
            'volume': 'Volumen',
            'temperature': 'Temperatur',
            'products': 'Produkte',
            'insulation': 'Isolierung',
            'floor_insulation': 'Bodenisolierung',
            'yes': 'Ja',
            'no': 'Nein',
            'operational_params': 'Betriebsparameter',
            'door_frequency': 'T√ºr√∂ffnungsfrequenz',
            'times_per_day': 'mal/Tag',
            'daily_loading': 'T√§gliche Beladung',
            'entry_temp': 'Produkteingangstemperatur',
            'cooling_capacity': 'K√ºhlkapazit√§t',
            'base_capacity': 'Grundkapazit√§t',
            'infiltration_load': 'Infiltrationslast',
            'product_load': 'Produktk√ºhlungslast',
            'floor_load': 'Bodenlast',
            'total_capacity': 'GESAMTKAPAZIT√ÑT',
            'in_kw': 'In kW'
        }
    }
    
    t = texts.get(language, texts['en'])
    
    result = f"‚ùÑÔ∏è {t['title']}\n\n"
    
    # Room specifications
    result += f"üìè {t['room_specs']}:\n"
    result += f"‚Ä¢ {t['dimensions']}: {answers['length']}m √ó {answers['width']}m √ó {answers['height']}m\n"
    result += f"‚Ä¢ {t['volume']}: {volume:.1f} m¬≥\n"
    result += f"‚Ä¢ {t['temperature']}: {answers['temperature']}¬∞C\n"
    result += f"‚Ä¢ {t['products']}: {answers['products']}\n"
    result += f"‚Ä¢ {t['insulation']}: {answers['insulation']} cm\n"
    result += f"‚Ä¢ {t['floor_insulation']}: {t['yes'] if answers['floor_insulation'] else t['no']}\n\n"
    
    # Operational parameters
    result += f"‚öôÔ∏è {t['operational_params']}:\n"
    result += f"‚Ä¢ {t['door_frequency']}: {answers['door_frequency']} {t['times_per_day']}\n"
    result += f"‚Ä¢ {t['daily_loading']}: {answers['loading_amount']} kg\n"
    result += f"‚Ä¢ {t['entry_temp']}: {answers['entry_temperature']}¬∞C\n\n"
    
    # Capacity calculation
    result += f"üîß {t['cooling_capacity']}:\n"
    result += f"‚Ä¢ {t['base_capacity']}: {round(final_capacity - additional_loads['total']):,} W\n"
    if additional_loads['infiltration'] > 0:
        result += f"‚Ä¢ {t['infiltration_load']}: {round(additional_loads['infiltration']):,} W\n"
    if additional_loads['product'] > 0:
        result += f"‚Ä¢ {t['product_load']}: {round(additional_loads['product']):,} W\n"
    if additional_loads['floor'] > 0:
        result += f"‚Ä¢ {t['floor_load']}: {round(additional_loads['floor']):,} W\n"
    result += f"‚Ä¢ *{t['total_capacity']}: {round(final_capacity):,} W*\n"
    result += f"‚Ä¢ *{t['in_kw']}: {(final_capacity / 1000):.1f} kW*\n\n"
    
    return result

def has_active_cold_storage_flow(user_id):
    """
    Check if user has an active cold storage flow
    Args:
        user_id (str): User ID
    Returns:
        bool: True if flow is active
    """
    return user_id in USER_SESSIONS and USER_SESSIONS[user_id]['active']

def cancel_cold_storage_flow(user_id):
    """
    Cancel current cold storage flow
    Args:
        user_id (str): User ID
    """
    if user_id in USER_SESSIONS:
        del USER_SESSIONS[user_id]

def detect_language(message):
    """
    Detect language from message
    Args:
        message (str): User message
    Returns:
        str: Language code
    """
    lower_message = message.lower()
    
    # Turkish keywords
    if any(word in lower_message for word in ['soƒüuk', 'oda', 'sƒ±caklƒ±k', 'hesapla', 'evet', 'hayƒ±r', 'iptal', 'dur']):
        return 'tr'
    
    # German keywords
    if any(word in lower_message for word in ['k√ºhlraum', 'temperatur', 'berechnen', 'berechnung', 'k√ºhlung', 'isolierung', 'h√§ufig', 'selten', 'ja', 'nein', 'abbrechen', 'meter', 'produkte', 'fleisch', 'obst', 'gem√ºse']):
        return 'de'
    
    # Default to English
    return 'en'