"""
Cold Storage Flow Handler for Python
Manages the step-by-step questionnaire for cold storage calculations
"""

import json
import re
from cold_room_calculator import calculate_capacity

# Question templates
QUESTIONS = {
    'en': {
        'temperature': "What is the required cold room temperature? (°C)\n\nSupported temperatures: 12, 5, 0, -5, -15, -18, -20, -25°C",
        'products': "What product(s) will be stored inside the room?\n\nExample: Fruits, vegetables, meat, dairy, etc.",
        'length': "What is the inner length of the room? (in meters)\n\nExample: 5.5",
        'width': "What is the inner width of the room? (in meters)\n\nExample: 3.2",
        'height': "What is the inner height of the room? (in meters)\n\nExample: 2.8",
        'insulation': "What is the thickness of insulation panels?\n\nExample: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Is there floor insulation?\n\nReply: Yes or No",
        'door_frequency': "How often will the door be opened daily?\n\nExample: 10 times, rarely, frequently",
        'loading_amount': "What is the daily loading/unloading amount? (in kg)\n\nExample: 500 kg",
        'entry_temperature': "What is the temperature of products when they enter the room? (°C)\n\nExample: 20°C",
        'cooling_duration': "What is the required cooling duration? (in hours)\n\nExample: 24 hours, 48 hours",
        'cooling_type': "What type of cooling system do you prefer?\n\nOptions: Air cooling, Direct expansion, Evaporative",
        'unit_preference': "What type of unit do you prefer?\n\nOptions: Monoblock, Split system, Modular system",
        'electricity_type': "What type of electricity supply?\n\nOptions: Single phase (220V), Three phase (380V/400V)",
        'installation_city': "In which city will the installation be?\n\nExample: Istanbul, Berlin, London",
        'ambient_heat_source': "Are there any ambient heat sources nearby?\n\nExample: Ovens, boilers, direct sunlight",
        'usage_area': "What is the usable area or number of pallets?\n\nExample: 50 m² or 20 pallets",
        'drawing_photo': "Do you have technical drawings or photos of the space?\n\nReply: Yes or No (you can send them later)"
    },
    'tr': {
        'temperature': "Gerekli soğuk oda sıcaklığı nedir? (°C)\n\nDesteklenen sıcaklıklar: 12, 5, 0, -5, -15, -18, -20, -25°C",
        'products': "Oda içerisinde hangi ürün(ler) saklanacak?\n\nÖrnek: Meyve, sebze, et, süt ürünleri, vb.",
        'length': "Odanın iç uzunluğu nedir? (metre cinsinden)\n\nÖrnek: 5.5",
        'width': "Odanın iç genişliği nedir? (metre cinsinden)\n\nÖrnek: 3.2",
        'height': "Odanın iç yüksekliği nedir? (metre cinsinden)\n\nÖrnek: 2.8",
        'insulation': "Yalıtım panellerinin kalınlığı nedir?\n\nÖrnek: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Zemin yalıtımı var mı?\n\nCevap: Evet veya Hayır",
        'door_frequency': "Kapı günde kaç kez açılacak?\n\nÖrnek: 10 kez, nadir, sık sık",
        'loading_amount': "Günlük yükleme/boşaltma miktarı nedir? (kg cinsinden)\n\nÖrnek: 500 kg",
        'entry_temperature': "Ürünler odaya girdiğinde sıcaklığı nedir? (°C)\n\nÖrnek: 20°C",
        'cooling_duration': "Gerekli soğuma süresi nedir? (saat cinsinden)\n\nÖrnek: 24 saat, 48 saat",
        'cooling_type': "Hangi tip soğutma sistemi tercih ediyorsunuz?\n\nSeçenekler: Hava soğutmalı, Direkt ekspansiyonlu, Evaporatif",
        'unit_preference': "Hangi tip ünite tercih ediyorsunuz?\n\nSeçenekler: Monoblock, Split sistem, Modüler sistem",
        'electricity_type': "Elektrik tipi nedir?\n\nSeçenekler: Tek faz (220V), Üç faz (380V/400V)",
        'installation_city': "Kurulum hangi şehirde yapılacak?\n\nÖrnek: İstanbul, Ankara, İzmir",
        'ambient_heat_source': "Çevrede ısı kaynağı var mı?\n\nÖrnek: Fırınlar, kazanlar, doğrudan güneş ışığı",
        'usage_area': "Kullanım alanı veya palet sayısı nedir?\n\nÖrnek: 50 m² veya 20 palet",
        'drawing_photo': "Mekanın teknik çizimi veya fotoğrafı var mı?\n\nCevap: Evet veya Hayır (daha sonra gönderebilirsiniz)"
    },
    'de': {
        'temperature': "Welche Kühlraumtemperatur ist erforderlich? (°C)\n\nUnterstützte Temperaturen: 12, 5, 0, -5, -15, -18, -20, -25°C",
        'products': "Welche Produkte werden im Raum gelagert?\n\nBeispiel: Obst, Gemüse, Fleisch, Milchprodukte, usw.",
        'length': "Wie lang ist der Raum innen? (in Metern)\n\nBeispiel: 5.5",
        'width': "Wie breit ist der Raum innen? (in Metern)\n\nBeispiel: 3.2",
        'height': "Wie hoch ist der Raum innen? (in Metern)\n\nBeispiel: 2.8",
        'insulation': "Wie dick sind die Isolierpaneele?\n\nBeispiel: 8 cm, 10 cm, 12 cm",
        'floor_insulation': "Gibt es eine Bodenisolierung?\n\nAntwort: Ja oder Nein",
        'door_frequency': "Wie oft wird die Tür täglich geöffnet?\n\nBeispiel: 10 mal, selten, häufig",
        'loading_amount': "Wie viel wird täglich be-/entladen? (in kg)\n\nBeispiel: 500 kg",
        'entry_temperature': "Welche Temperatur haben die Produkte beim Einlagern? (°C)\n\nBeispiel: 20°C",
        'cooling_duration': "Wie lange soll die Kühlung dauern? (in Stunden)\n\nBeispiel: 24 Stunden, 48 Stunden",
        'cooling_type': "Welchen Kühlungstyp bevorzugen Sie?\n\nOptionen: Luftkühlung, Direktexpansion, Verdunstungskühlung",
        'unit_preference': "Welchen Gerätetyp bevorzugen Sie?\n\nOptionen: Monoblock, Split-System, Modulares System",
        'electricity_type': "Welcher Stromtyp?\n\nOptionen: Einphasig (220V), Dreiphasig (380V/400V)",
        'installation_city': "In welcher Stadt erfolgt die Installation?\n\nBeispiel: Berlin, München, Hamburg",
        'ambient_heat_source': "Gibt es Wärmequellen in der Umgebung?\n\nBeispiel: Öfen, Kessel, direktes Sonnenlicht",
        'usage_area': "Wie groß ist die Nutzfläche oder wie viele Paletten?\n\nBeispiel: 50 m² oder 20 Paletten",
        'drawing_photo': "Haben Sie technische Zeichnungen oder Fotos des Raums?\n\nAntwort: Ja oder Nein (können später gesendet werden)"
    }
}

# Progress messages
PROGRESS_MESSAGES = {
    'en': {
        'progress': "Progress: {current}/{total} questions completed",
        'calculation': "🔄 Calculating your cold storage requirements...",
        'complete': "✅ Calculation complete! Here are your results:",
        'restart': "To start a new calculation, send 'cold room' or 'soğuk oda'."
    },
    'tr': {
        'progress': "İlerleme: {current}/{total} soru tamamlandı",
        'calculation': "🔄 Soğuk hava deposu gereksinimleriniz hesaplanıyor...",
        'complete': "✅ Hesaplama tamamlandı! İşte sonuçlarınız:",
        'restart': "Yeni bir hesaplama başlatmak için 'cold room' veya 'soğuk oda' gönderin."
    },
    'de': {
        'progress': "Fortschritt: {current}/{total} Fragen beantwortet",
        'calculation': "🔄 Ihre Kühlraum-Anforderungen werden berechnet...",
        'complete': "✅ Berechnung abgeschlossen! Hier sind Ihre Ergebnisse:",
        'restart': "Für eine neue Berechnung senden Sie 'cold room' oder 'kühlraum'."
    }
}

# Question flow order - Updated to match JavaScript version with 18 questions
QUESTION_ORDER = [
    'temperature',
    'products',
    'length',
    'width',
    'height',
    'insulation',
    'floor_insulation',
    'door_frequency',
    'loading_amount',
    'entry_temperature',
    'cooling_duration',
    'cooling_type',
    'unit_preference',
    'electricity_type',
    'installation_city',
    'ambient_heat_source',
    'usage_area',
    'drawing_photo'
]

# In-memory storage for user sessions (in production, use a database)
USER_SESSIONS = {}

def initialize_cold_storage_flow(user_id, language='en'):
    """
    Initialize cold storage flow for a user
    Args:
        user_id (str): User ID
        language (str): Language code (en/tr/de)
    Returns:
        str: Welcome message and first question
    """
    USER_SESSIONS[user_id] = {
        'active': True,
        'language': language,
        'current_step': 0,
        'answers': {},
        'start_time': None
    }
    
    # Welcome messages with commands
    welcome_messages = {
        'en': "❄️ Welcome to the Cold Room Calculator! 🧊\n\nI'll help you calculate the exact cooling capacity needed for your cold storage room. We'll go through 18 comprehensive questions to get accurate results.\n\n📋 **HELPFUL COMMANDS YOU CAN USE:**\n✅ Type **'wrong'** if you made a mistake\n✅ Type **'show'** to see all your answers\n✅ Type **'restart'** to start over completely\n✅ Type **'stop'** to exit\n\n💡 You can use these commands at any time during the questions!\n\n🎯 Let's get started!",
        'tr': "❄️ Soğuk Oda Hesaplayıcısına Hoş Geldiniz! 🧊\n\nSoğuk hava deponuz için gereken tam soğutma kapasitesini hesaplamanıza yardımcı olacağım. Doğru sonuçlar için 18 kapsamlı soru soracağım.\n\n📋 **KULLANABİLECEĞİNİZ YARDIMCI KOMUTLAR:**\n✅ Hata yaptıysanız **'yanlış'** yazın\n✅ Tüm cevaplarınızı görmek için **'göster'** yazın\n✅ Tamamen yeniden başlamak için **'restart'** yazın\n✅ Çıkmak için **'dur'** yazın\n\n💡 Bu komutları sorular sırasında istediğiniz zaman kullanabilirsiniz!\n\n🎯 Hadi başlayalım!",
        'de': "❄️ Willkommen beim Kühlraum-Rechner! 🧊\n\nIch helfe Ihnen bei der Berechnung der exakten Kühlkapazität für Ihren Kühlraum. Wir gehen 18 umfassende Fragen durch, um genaue Ergebnisse zu erhalten.\n\n📋 **HILFREICHE BEFEHLE DIE SIE VERWENDEN KÖNNEN:**\n✅ Geben Sie **'falsch'** ein, wenn Sie einen Fehler gemacht haben\n✅ Geben Sie **'zeigen'** ein, um alle Ihre Antworten zu sehen\n✅ Geben Sie **'restart'** ein, um komplett neu zu beginnen\n✅ Geben Sie **'stopp'** ein, um zu beenden\n\n💡 Sie können diese Befehle jederzeit während der Fragen verwenden!\n\n🎯 Los geht's!"
    }
    
    welcome_message = welcome_messages.get(language, welcome_messages['en'])
    first_question = ask_current_question(user_id)
    
    return f"{welcome_message}\n\n{first_question}"

def process_answer(user_id, answer):
    """
    Process user answer and move to next question
    Args:
        user_id (str): User ID
        answer (str): User's answer
    Returns:
        str: Next question or calculation result
    """
    if user_id not in USER_SESSIONS:
        return "No active session found. Please start a new calculation."
    
    session = USER_SESSIONS[user_id]
    
    # Check for special commands first
    if is_cancel_request(answer):
        return cancel_cold_storage_flow(user_id)
    
    if is_back_request(answer):
        return go_back_to_previous_question(user_id)
    
    if is_restart_request(answer):
        # Reset the flow
        session['current_step'] = 0
        session['answers'] = {}
        restart_messages = {
            'en': f"🔄 Restarting cold storage calculation...\n\n{ask_current_question(user_id)}",
            'tr': f"🔄 Soğuk depo hesaplaması yeniden başlatılıyor...\n\n{ask_current_question(user_id)}",
            'de': f"🔄 Kältelagerberechnung wird neu gestartet...\n\n{ask_current_question(user_id)}"
        }
        return restart_messages.get(session['language'], restart_messages['en'])
    
    if is_show_request(answer):
        return show_current_answers(user_id)
    
    current_question_key = QUESTION_ORDER[session['current_step']]
    
    # Validate and store answer
    validation_result = validate_answer(current_question_key, answer)
    if validation_result['error']:
        # Add helpful commands reminder when there's an error
        help_texts = {
            'en': "\n\n💡 Need help? Type 'wrong' to go back, 'show' to see answers, or 'restart' to start over.",
            'tr': "\n\n💡 Yardım mı lazım? 'yanlış' yazarak geri gidin, 'göster' ile cevapları görün, ya da 'restart' ile yeniden başlayın.",
            'de': "\n\n💡 Hilfe benötigt? Geben Sie 'falsch' ein um zurückzugehen, 'zeigen' für Antworten, oder 'restart' für Neustart."
        }
        help_text = help_texts.get(session['language'], help_texts['en'])
        return validation_result['error'] + "\n\n" + QUESTIONS[session['language']][current_question_key] + help_text
    
    session['answers'][current_question_key] = validation_result['value']
    session['current_step'] += 1
    
    # Check if all questions are answered
    if session['current_step'] >= len(QUESTION_ORDER):
        return calculate_and_finish(user_id)
    
    return ask_current_question(user_id)

def ask_current_question(user_id):
    """
    Ask the current question
    Args:
        user_id (str): User ID
    Returns:
        str: Current question with commands
    """
    session = USER_SESSIONS[user_id]
    current_question_key = QUESTION_ORDER[session['current_step']]
    question = QUESTIONS[session['language']][current_question_key]
    
    progress = PROGRESS_MESSAGES[session['language']]['progress'].format(
        current=session['current_step'] + 1,
        total=len(QUESTION_ORDER)
    )
    
    # Add helpful commands
    command_texts = {
        'en': "\n\n💬 Commands: 'wrong' | 'show' | 'restart' | 'stop'",
        'tr': "\n\n💬 Komutlar: 'yanlış' | 'göster' | 'restart' | 'dur'",
        'de': "\n\n💬 Befehle: 'falsch' | 'zeigen' | 'restart' | 'stopp'"
    }
    
    command_text = command_texts.get(session['language'], command_texts['en'])
    
    return f"{progress}\n\n{question}{command_text}"

def validate_answer(question_key, answer):
    """
    Validate user answer based on question type
    Args:
        question_key (str): Question identifier
        answer (str): User's answer
    Returns:
        dict: Validation result with 'error' and 'value' keys
    """
    clean_answer = answer.strip()
    
    if question_key == 'temperature':
        try:
            temp = float(re.sub(r'[°C]', '', clean_answer))
            supported_temps = [12, 5, 0, -5, -15, -18, -20, -25]
            if temp not in supported_temps:
                return {'error': "❌ Please enter a valid temperature from the supported list.", 'value': None}
            return {'error': None, 'value': temp}
        except ValueError:
            return {'error': "❌ Please enter a valid temperature from the supported list.", 'value': None}
    
    elif question_key == 'products':
        if len(clean_answer) < 2:
            return {'error': "❌ Please describe the products to be stored.", 'value': None}
        return {'error': None, 'value': clean_answer}
    
    elif question_key in ['length', 'width', 'height']:
        try:
            dimension = float(re.sub(r'[m]', '', clean_answer))
            if dimension <= 0 or dimension > 50:
                return {'error': "❌ Please enter a valid dimension in meters (0.1 - 50).", 'value': None}
            return {'error': None, 'value': dimension}
        except ValueError:
            return {'error': "❌ Please enter a valid dimension in meters (0.1 - 50).", 'value': None}
    
    elif question_key == 'insulation':
        try:
            thickness = float(re.sub(r'[cm]', '', clean_answer))
            if thickness < 5 or thickness > 30:
                return {'error': "❌ Please enter insulation thickness in cm (5-30 cm).", 'value': None}
            return {'error': None, 'value': thickness}
        except ValueError:
            return {'error': "❌ Please enter insulation thickness in cm (5-30 cm).", 'value': None}
    
    elif question_key == 'floor_insulation':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['yes', 'evet', 'ja']):
            return {'error': None, 'value': True}
        elif any(word in lower_answer for word in ['no', 'hayır', 'nein']):
            return {'error': None, 'value': False}
        else:
            return {'error': "❌ Please answer 'Yes'/'Evet'/'Ja' or 'No'/'Hayır'/'Nein' for floor insulation.", 'value': None}
    
    elif question_key == 'door_frequency':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['rare', 'nadir', 'selten']):
            return {'error': None, 'value': 2}
        elif any(word in lower_answer for word in ['frequent', 'sık', 'häufig']):
            return {'error': None, 'value': 20}
        else:
            try:
                number = int(re.sub(r'[^0-9]', '', clean_answer))
                if 0 <= number <= 100:
                    return {'error': None, 'value': number}
                else:
                    return {'error': "❌ Please enter door opening frequency (number of times per day or 'rarely'/'frequently').", 'value': None}
            except ValueError:
                return {'error': "❌ Please enter door opening frequency (number of times per day or 'rarely'/'frequently').", 'value': None}
    
    elif question_key == 'loading_amount':
        try:
            amount = float(re.sub(r'[kg]', '', clean_answer))
            if amount < 0 or amount > 50000:
                return {'error': "❌ Please enter daily loading amount in kg (0-50000).", 'value': None}
            return {'error': None, 'value': amount}
        except ValueError:
            return {'error': "❌ Please enter daily loading amount in kg (0-50000).", 'value': None}
    
    elif question_key == 'entry_temperature':
        try:
            temp = float(re.sub(r'[°C]', '', clean_answer))
            if temp < -30 or temp > 60:
                return {'error': "❌ Please enter product entry temperature in °C (-30 to 60).", 'value': None}
            return {'error': None, 'value': temp}
        except ValueError:
            return {'error': "❌ Please enter product entry temperature in °C (-30 to 60).", 'value': None}
    
    elif question_key == 'cooling_duration':
        try:
            duration = float(re.sub(r'(hours|hour|saat|stunden)', '', clean_answer, flags=re.IGNORECASE))
            if duration < 1 or duration > 168:
                return {'error': "❌ Please enter cooling duration in hours (1-168 hours).", 'value': None}
            return {'error': None, 'value': duration}
        except ValueError:
            return {'error': "❌ Please enter cooling duration in hours (1-168 hours).", 'value': None}
    
    elif question_key == 'cooling_type':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['air', 'hava', 'luft']):
            return {'error': None, 'value': 'air'}
        elif any(word in lower_answer for word in ['direct', 'direkt']):
            return {'error': None, 'value': 'direct'}
        elif any(word in lower_answer for word in ['evap', 'verdun']):
            return {'error': None, 'value': 'evaporative'}
        else:
            return {'error': "❌ Please select: Air cooling, Direct expansion, or Evaporative.", 'value': None}
    
    elif question_key == 'unit_preference':
        lower_answer = clean_answer.lower()
        if 'mono' in lower_answer:
            return {'error': None, 'value': 'monoblock'}
        elif 'split' in lower_answer:
            return {'error': None, 'value': 'split'}
        elif 'modul' in lower_answer:
            return {'error': None, 'value': 'modular'}
        else:
            return {'error': "❌ Please select: Monoblock, Split system, or Modular system.", 'value': None}
    
    elif question_key == 'electricity_type':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['single', 'tek', '220']):
            return {'error': None, 'value': 'single'}
        elif any(word in lower_answer for word in ['three', 'üç', 'drei', '380', '400']):
            return {'error': None, 'value': 'three'}
        else:
            return {'error': "❌ Please select: Single phase (220V) or Three phase (380V/400V).", 'value': None}
    
    elif question_key == 'installation_city':
        if len(clean_answer) < 2:
            return {'error': "❌ Please enter the installation city name.", 'value': None}
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'ambient_heat_source':
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'usage_area':
        return {'error': None, 'value': clean_answer}
    
    elif question_key == 'drawing_photo':
        lower_answer = clean_answer.lower()
        if any(word in lower_answer for word in ['yes', 'evet', 'ja']):
            return {'error': None, 'value': True}
        elif any(word in lower_answer for word in ['no', 'hayır', 'nein']):
            return {'error': None, 'value': False}
        else:
            return {'error': "❌ Please answer 'Yes'/'Evet'/'Ja' or 'No'/'Hayır'/'Nein'.", 'value': None}
    
    return {'error': "❌ Invalid question type.", 'value': None}

def is_cancel_request(message):
    """Check if user wants to cancel current session"""
    cancel_keywords = ['cancel', 'stop', 'quit', 'exit', 'iptal', 'dur', 'çık', 'abbrechen', 'stopp', 'beenden']
    return message.lower().strip() in cancel_keywords

def is_back_request(message):
    """Check if user wants to go back to previous question"""
    back_keywords = ['back', 'previous', 'go back', 'geri', 'önceki', 'zurück', 'vorherige', 'wrong', 'mistake', 'error', 'yanlış', 'hata', 'falsch', 'fehler']
    return any(keyword in message.lower() for keyword in back_keywords)

def is_restart_request(message):
    """Check if user wants to restart calculation"""
    restart_keywords = ['restart', 'start over', 'begin again', 'yeniden başla', 'tekrar başla', 'neu starten', 'von vorne']
    return any(keyword in message.lower() for keyword in restart_keywords)

def is_show_request(message):
    """Check if user wants to show current answers"""
    show_keywords = ['show', 'display', 'review', 'answers', 'göster', 'cevaplar', 'zeigen', 'antworten']
    return any(keyword in message.lower() for keyword in show_keywords)

def cancel_cold_storage_flow(user_id):
    """Cancel active cold storage session"""
    if user_id in USER_SESSIONS:
        language = USER_SESSIONS[user_id].get('language', 'en')
        del USER_SESSIONS[user_id]
        
        messages = {
            'en': "❌ Cold storage calculation cancelled. Type 'cold storage' to start again.",
            'tr': "❌ Soğuk depo hesaplaması iptal edildi. Tekrar başlamak için 'soğuk depo' yazın.",
            'de': "❌ Kältelagerberechnung abgebrochen. Geben Sie 'Kühlraum' ein, um erneut zu beginnen."
        }
        
        return messages.get(language, messages['en'])
    
    return None

def go_back_to_previous_question(user_id):
    """Go back to previous question"""
    if user_id not in USER_SESSIONS:
        return "No active session found."
    
    session = USER_SESSIONS[user_id]
    language = session['language']
    
    if session['current_step'] <= 0:
        messages = {
            'en': "❌ You're already at the first question. Type 'restart' to start over.",
            'tr': "❌ Zaten ilk sorudasınız. Yeniden başlamak için 'restart' yazın.",
            'de': "❌ Sie sind bereits bei der ersten Frage. Geben Sie 'restart' ein, um von vorne zu beginnen."
        }
        return messages.get(language, messages['en'])
    
    # Go back one step and remove the previous answer
    session['current_step'] -= 1
    previous_question_key = QUESTION_ORDER[session['current_step']]
    if previous_question_key in session['answers']:
        del session['answers'][previous_question_key]
    
    back_messages = {
        'en': "⬅️ Going back to previous question:",
        'tr': "⬅️ Önceki soruya dönülüyor:",
        'de': "⬅️ Zurück zur vorherigen Frage:"
    }
    
    back_message = back_messages.get(language, back_messages['en'])
    question = ask_current_question(user_id)
    
    return f"{back_message}\n\n{question}"

def show_current_answers(user_id):
    """Show current answers for review"""
    if user_id not in USER_SESSIONS:
        return "No active session found."
    
    session = USER_SESSIONS[user_id]
    language = session['language']
    answers = session['answers']
    
    headers = {
        'en': {
            'title': "📋 Your Current Answers:",
            'noAnswers': "❌ No answers recorded yet.",
            'commands': "\n💡 Commands:\n• Type 'back' to go to previous question\n• Type 'restart' to start over\n• Continue answering to proceed"
        },
        'tr': {
            'title': "📋 Mevcut Cevaplarınız:",
            'noAnswers': "❌ Henüz hiç cevap kaydedilmedi.",
            'commands': "\n💡 Komutlar:\n• Önceki soruya dönmek için 'back' yazın\n• Yeniden başlamak için 'restart' yazın\n• Devam etmek için cevaplamaya devam edin"
        },
        'de': {
            'title': "📋 Ihre aktuellen Antworten:",
            'noAnswers': "❌ Noch keine Antworten aufgezeichnet.",
            'commands': "\n💡 Befehle:\n• Geben Sie 'back' ein, um zur vorherigen Frage zu gehen\n• Geben Sie 'restart' ein, um von vorne zu beginnen\n• Setzen Sie das Beantworten fort, um fortzufahren"
        }
    }
    
    h = headers.get(language, headers['en'])
    
    if len(answers) == 0:
        return h['noAnswers'] + h['commands']
    
    response = h['title'] + "\n\n"
    
    for i in range(session['current_step']):
        question_key = QUESTION_ORDER[i]
        answer = answers.get(question_key)
        if answer is not None:
            response += f"{i + 1}. {question_key}: {answer}\n"
    
    response += h['commands']
    return response

def calculate_and_finish(user_id):
    """
    Calculate results and finish the flow
    Args:
        user_id (str): User ID
    Returns:
        str: Final calculation result
    """
    session = USER_SESSIONS[user_id]
    answers = session['answers']
    
    try:
        # Calculate room volume
        volume = answers['length'] * answers['width'] * answers['height']
        
        # Estimate ambient temperature based on geographical assumptions
        ambient_temp = 35  # Default assumption for calculations
        
        # Calculate additional loads
        additional_loads = calculate_additional_loads(answers)
        
        # Base calculation parameters
        calc_params = {
            'volume': volume,
            'temperature': answers['temperature'],
            'ambient_temp': ambient_temp,
            'climate_zone': 'cool',  # Default
            'safety_factor': 1.2  # Default safety factor
        }
        
        # Get base calculation
        base_result = calculate_capacity(**calc_params)
        
        # Add additional loads
        final_capacity = base_result['final_capacity'] + additional_loads['total']
        
        # Format comprehensive result
        result = format_cold_storage_result(answers, volume, final_capacity, additional_loads, session['language'])
        
        # Clean up session
        del USER_SESSIONS[user_id]
        
        return PROGRESS_MESSAGES[session['language']]['complete'] + "\n\n" + result + "\n\n" + PROGRESS_MESSAGES[session['language']]['restart']
        
    except Exception as error:
        del USER_SESSIONS[user_id]
        return "❌ Sorry, there was an error calculating your requirements. Please try again."

def calculate_additional_loads(answers):
    """
    Calculate additional loads based on specific parameters
    Args:
        answers (dict): User answers
    Returns:
        dict: Additional loads breakdown
    """
    loads = {
        'infiltration': 0,
        'product': 0,
        'floor': 0,
        'total': 0
    }
    
    volume = answers['length'] * answers['width'] * answers['height']
    
    # Infiltration load (door openings)
    infiltration_factor = min(answers['door_frequency'] * 0.1, 2.0)  # Max 200% increase
    loads['infiltration'] = volume * infiltration_factor * 15  # 15W per m³ per door opening factor
    
    # Product load (cooling from entry temperature to storage temperature)
    temp_diff = answers['entry_temperature'] - answers['temperature']
    product_load = answers['loading_amount'] * temp_diff * 0.5  # Simplified: 0.5W per kg per °C difference
    loads['product'] = max(product_load, 0)
    
    # Floor load (if no insulation)
    if not answers['floor_insulation']:
        loads['floor'] = answers['length'] * answers['width'] * 20  # 20W per m² for uninsulated floor
    
    loads['total'] = loads['infiltration'] + loads['product'] + loads['floor']
    
    return loads

def format_cold_storage_result(answers, volume, final_capacity, additional_loads, language):
    """
    Format the final calculation result
    Args:
        answers (dict): User answers
        volume (float): Room volume
        final_capacity (float): Final cooling capacity
        additional_loads (dict): Additional loads breakdown
        language (str): Language code
    Returns:
        str: Formatted result
    """
    # Language-specific text mappings
    texts = {
        'en': {
            'title': 'Cold Storage Calculation Results',
            'room_specs': 'Room Specifications',
            'dimensions': 'Dimensions',
            'volume': 'Volume',
            'temperature': 'Temperature',
            'products': 'Products',
            'insulation': 'Insulation',
            'floor_insulation': 'Floor Insulation',
            'yes': 'Yes',
            'no': 'No',
            'operational_params': 'Operational Parameters',
            'door_frequency': 'Door Opening Frequency',
            'times_per_day': 'times/day',
            'daily_loading': 'Daily Loading',
            'entry_temp': 'Product Entry Temperature',
            'cooling_capacity': 'Cooling Capacity',
            'base_capacity': 'Base Capacity',
            'infiltration_load': 'Infiltration Load',
            'product_load': 'Product Cooling Load',
            'floor_load': 'Floor Load',
            'total_capacity': 'TOTAL CAPACITY',
            'in_kw': 'In kW'
        },
        'tr': {
            'title': 'Soğuk Hava Deposu Hesaplama Sonuçları',
            'room_specs': 'Oda Özellikleri',
            'dimensions': 'Boyutlar',
            'volume': 'Hacim',
            'temperature': 'Sıcaklık',
            'products': 'Ürün',
            'insulation': 'Yalıtım',
            'floor_insulation': 'Zemin Yalıtımı',
            'yes': 'Var',
            'no': 'Yok',
            'operational_params': 'Çalışma Parametreleri',
            'door_frequency': 'Kapı Açma Sıklığı',
            'times_per_day': 'kez/gün',
            'daily_loading': 'Günlük Yükleme',
            'entry_temp': 'Ürün Giriş Sıcaklığı',
            'cooling_capacity': 'Soğutma Kapasitesi',
            'base_capacity': 'Temel Kapasite',
            'infiltration_load': 'Infiltrasyon Yükü',
            'product_load': 'Ürün Soğutma Yükü',
            'floor_load': 'Zemin Yükü',
            'total_capacity': 'TOPLAM KAPASİTE',
            'in_kw': 'kW Cinsinden'
        },
        'de': {
            'title': 'Kühlraum-Berechnungsergebnisse',
            'room_specs': 'Raum-Spezifikationen',
            'dimensions': 'Abmessungen',
            'volume': 'Volumen',
            'temperature': 'Temperatur',
            'products': 'Produkte',
            'insulation': 'Isolierung',
            'floor_insulation': 'Bodenisolierung',
            'yes': 'Ja',
            'no': 'Nein',
            'operational_params': 'Betriebsparameter',
            'door_frequency': 'Türöffnungsfrequenz',
            'times_per_day': 'mal/Tag',
            'daily_loading': 'Tägliche Beladung',
            'entry_temp': 'Produkteingangstemperatur',
            'cooling_capacity': 'Kühlkapazität',
            'base_capacity': 'Grundkapazität',
            'infiltration_load': 'Infiltrationslast',
            'product_load': 'Produktkühlungslast',
            'floor_load': 'Bodenlast',
            'total_capacity': 'GESAMTKAPAZITÄT',
            'in_kw': 'In kW'
        }
    }
    
    t = texts.get(language, texts['en'])
    
    result = f"❄️ {t['title']}\n\n"
    
    # Room specifications
    result += f"📏 {t['room_specs']}:\n"
    result += f"• {t['dimensions']}: {answers['length']}m × {answers['width']}m × {answers['height']}m\n"
    result += f"• {t['volume']}: {volume:.1f} m³\n"
    result += f"• {t['temperature']}: {answers['temperature']}°C\n"
    result += f"• {t['products']}: {answers['products']}\n"
    result += f"• {t['insulation']}: {answers['insulation']} cm\n"
    result += f"• {t['floor_insulation']}: {t['yes'] if answers['floor_insulation'] else t['no']}\n\n"
    
    # Operational parameters
    result += f"⚙️ {t['operational_params']}:\n"
    result += f"• {t['door_frequency']}: {answers['door_frequency']} {t['times_per_day']}\n"
    result += f"• {t['daily_loading']}: {answers['loading_amount']} kg\n"
    result += f"• {t['entry_temp']}: {answers['entry_temperature']}°C\n\n"
    
    # Capacity calculation
    result += f"🔧 {t['cooling_capacity']}:\n"
    result += f"• {t['base_capacity']}: {round(final_capacity - additional_loads['total']):,} W\n"
    if additional_loads['infiltration'] > 0:
        result += f"• {t['infiltration_load']}: {round(additional_loads['infiltration']):,} W\n"
    if additional_loads['product'] > 0:
        result += f"• {t['product_load']}: {round(additional_loads['product']):,} W\n"
    if additional_loads['floor'] > 0:
        result += f"• {t['floor_load']}: {round(additional_loads['floor']):,} W\n"
    result += f"• *{t['total_capacity']}: {round(final_capacity):,} W*\n"
    result += f"• *{t['in_kw']}: {(final_capacity / 1000):.1f} kW*\n\n"
    
    return result

def has_active_cold_storage_flow(user_id):
    """
    Check if user has an active cold storage flow
    Args:
        user_id (str): User ID
    Returns:
        bool: True if flow is active
    """
    return user_id in USER_SESSIONS and USER_SESSIONS[user_id]['active']

def cancel_cold_storage_flow(user_id):
    """
    Cancel current cold storage flow
    Args:
        user_id (str): User ID
    """
    if user_id in USER_SESSIONS:
        del USER_SESSIONS[user_id]

def detect_language(message):
    """
    Detect language from message
    Args:
        message (str): User message
    Returns:
        str: Language code
    """
    lower_message = message.lower()
    
    # Turkish keywords
    if any(word in lower_message for word in ['soğuk', 'oda', 'sıcaklık', 'hesapla', 'evet', 'hayır', 'iptal', 'dur']):
        return 'tr'
    
    # German keywords
    if any(word in lower_message for word in ['kühlraum', 'temperatur', 'berechnen', 'berechnung', 'kühlung', 'isolierung', 'häufig', 'selten', 'ja', 'nein', 'abbrechen', 'meter', 'produkte', 'fleisch', 'obst', 'gemüse']):
        return 'de'
    
    # Default to English
    return 'en'